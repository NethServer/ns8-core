#!/usr/bin/env python3

#
# Copyright (C) 2024 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-3.0-or-later
#

import asyncio
import aiohttp
import multiprocessing
import sys
import os
import agent
from aiohttp import web

# Alarm states
UNKNOWN = 'U'
CLEAR = '0'
CRITICAL = 'F'

nmenv = agent.read_envfile("node-monitor.env")

# Prepare runtime parameters
node_name = 'node_' + os.environ['NODE_ID']
auth_token = nmenv.get("NMON_ALERT_AUTH_TOKEN")
alert_provider = nmenv.get("NMON_ALERT_PROVIDER")
system_id = nmenv.get("NMON_ALERT_SYSTEM_ID")
dartagnan_url = nmenv.get("NMON_DARTAGNAN_URL")
cpu_count = multiprocessing.cpu_count()

def parse_meminfo():
    meminfo = {}
    with open("/proc/meminfo", encoding='utf-8', newline="\n") as fmem:
        for line in fmem:
            key, value, unit, _ = (line.rstrip("\n") + ' 0 0 0').split(maxsplit=3)
            meminfo[key.rstrip(":")] = value
    return meminfo

async def send_alert(url, value, alert, retry=3):
    if value == CLEAR:
        astatus = 'OK'
    elif value == CRITICAL:
        astatus = 'FAILURE'
    else:
        return
    ctimeout = aiohttp.ClientTimeout(total=60.0, connect=50, sock_connect=40, sock_read=10)
    ex_message = None
    try:
        async with aiohttp.ClientSession(timeout=ctimeout, headers={'Authorization': 'token ' + auth_token}) as cs:
            await cs.post(url, json={"lk":system_id, "alert_id": alert, "status": astatus})
    except Exception as ex:
        ex_message = str(ex)
    if ex_message:
        if retry > 0:
            print(agent.SD_DEBUG + "send_alert temporary failure:", value, alert, ex_message, f"-- retrying in 20 seconds", file=sys.stderr)
            await asyncio.sleep(20)
            await send_alert(url, value, alert, retry - 1)
        else:
            print(agent.SD_ERR + "send_alert aborted:", value, alert, ex_message, file=sys.stderr)

async def raise_alert(value, alert):
    if value == CLEAR:
        svalue = 'CLEAR'
    elif value == CRITICAL:
        svalue = 'CRITICAL'
    else:
        svalue = 'UNKNOWN'
    if alert.startswith('load'):
        print('NOTICE', svalue, alert, file=sys.stderr)
        return # do not send load alarm at all, just log it
    else:
        print('ALERT', svalue, alert, file=sys.stderr)
    if alert_provider == 'nsent':
        await send_alert('https://my.nethesis.it/isa/alerts/store', value, alert)
    elif alert_provider == 'nscom':
        await send_alert(f'{dartagnan_url}/machine/alerts/store', value, alert)

async def check_swap_presence():
    meminfo = parse_meminfo()
    if int(meminfo['SwapTotal']) == 0:
        return (CRITICAL, 'swap:notpresent:' + node_name)
    else:
        return (CLEAR, 'swap:notpresent:' + node_name)

async def check_backup():
    state = UNKNOWN
    try:
        with open("/run/backup-monitor.dat", "rb") as fbackup:
            fstate = fbackup.read(1)
        if fstate == b'0':
            state = CLEAR
        elif fstate == b'F':
            state = CRITICAL
    except FileNotFoundError:
        pass
    return (state, 'system:backup:failure')

async def monitor_loop(check_function, fargs=[], fkwargs={}, period=2, hysteresis=4):
    # hysteresis counts how many past checks are considered to build the
    # alarm state
    state_buffer = [CLEAR,] * hysteresis
    alarm_state = UNKNOWN # force initial transition to CLEAR
    head = 0

    def current_state():
        return state_buffer[head]

    # the alarm state changes when all past checks are equal and different
    # from the last alarm state
    def check_alarm():
        return alarm_state != current_state() and all(x == current_state() for x in state_buffer)

    while True:
        (value, alert) = await check_function(*fargs, **fkwargs)
        state_buffer[head] = value # update current state
        if check_alarm():
            alarm_state = value
            await raise_alert(value, alert)
        await asyncio.sleep(period)
        head = (head + 1) % hysteresis

async def handle_post_request(request):
    # Convert alertsmanager alerts into my alert format
    try:
        data = await request.json()
        alerts = data.get('alerts', [])
        for alert in alerts:
            status = alert.get('status')
            labels = alert.get('labels', {})
            node_id = labels.get('node', 'unknown')
            # Remap to my alert id format
            alert_name = labels.get('alertname', 'unknown').replace('_', ':')
            alert_id = f"{alert_name}:{node_id}"
            if status == 'firing':
                value = CRITICAL
            elif status == 'resolved':
                value = CLEAR
            else:
                value = UNKNOWN
            await raise_alert(value, alert_id)
        return aiohttp.web.Response(text="Alerts processed", status=200)
    except Exception as e:
        return aiohttp.web.Response(text=str(e), status=500)

async def start_proxy_server():
    app = web.Application()
    app.router.add_post('/', handle_post_request)
    runner = aiohttp.web.AppRunner(app)
    await runner.setup()
    site = aiohttp.web.TCPSite(runner, '0.0.0.0', 9095)
    await site.start()
    print(agent.SD_INFO + "Alert proxy server started", file=sys.stderr)

async def main():
    # Run the alert proxy server
    proxy_server_task = asyncio.create_task(start_proxy_server())
    # Run each check inside a monitor loop in parallel:
    await asyncio.gather(
        proxy_server_task,
        monitor_loop(check_swap_presence, period=60, hysteresis=30), # 30 minutes
        monitor_loop(check_backup, period=10, hysteresis=1),
    )

asyncio.run(main())
