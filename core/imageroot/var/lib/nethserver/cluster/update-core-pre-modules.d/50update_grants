#!/usr/bin/env python3

#
# Copyright (C) 2024 Nethesis S.r.l.
# SPDX-License-Identifier: GPL-3.0-or-later
#

import os
import sys
import agent
import cluster.grants
import cluster.backup

rdb = agent.redis_connect(privileged=True)

#
# Update existing grants for features #6814, #6825, #6852
#
cluster.grants.grant(rdb, action_clause="bind-user-domains",  to_clause="accountconsumer", on_clause='cluster')
cluster.grants.grant(rdb, action_clause="bind-user-domains",  to_clause="accountprovider", on_clause='cluster')
cluster.grants.grant(rdb, action_clause="list-modules",  to_clause="accountprovider", on_clause='cluster')

for node_id in set(rdb.hvals('cluster/module_node')):
    # Reuse and reallocate TCP/UDP port range #6974:
    cluster.grants.grant(rdb, "allocate-ports", f'node/{node_id}', "portsadm")
    cluster.grants.grant(rdb, "deallocate-ports", f'node/{node_id}', "portsadm")
    # Fix rich rules management #7836:
    cluster.grants.grant(rdb, "add-rich-rules",  f'node/{node_id}', "fwadm")
    cluster.grants.grant(rdb, "remove-rich-rules", f'node/{node_id}', "fwadm")
    cluster.grants.grant(rdb, "add-rich-rules",  f'node/{node_id}', "tunadm")
    cluster.grants.grant(rdb, "remove-rich-rules", f'node/{node_id}', "tunadm")
    rdb.delete(
        f'node/{node_id}/roles/fwadm,portsadm',
        f'node/{node_id}/roles/tunadm,portsadm',
    )

#
# END of grant updates
#
cluster.grants.refresh_permissions(rdb)

# Grant nodes access to private/ key namespace to share backup secrets
trx = rdb.pipeline()
for acl_entry in rdb.acl_list():
    if not acl_entry.startswith("user node/"):
        continue # not a node entry
    acl_fields = acl_entry.split()
    if "%R~private/nodes/*" in acl_fields:
        continue # already upgraded to Core 3.18+
    agent_id = acl_fields[1]
    trx.acl_setuser(agent_id, "~private/{agent_id}/*", "%R~private/nodes/*")
trx_changes = trx.execute()
if len(trx_changes) > 0:
    # Migrate backup destinations, one by one:
    for krepo in list(rdb.scan_iter('cluster/backup_repository/*')):
        try:
            # Collect existing backup repository attributes, and migrate to new DB keys:
            destination_uuid = krepo.removeprefix('cluster/backup_repository/')
            if rdb.hexists('private/nodes/backup_destination/rclone_conf', destination_uuid):
                continue # skip if already migrated
            mgx = rdb.pipeline() # Accumulate all repo changes in one command pipeline
            odest = rdb.hgetall(krepo)
            rclone_conf, destination_basepath = cluster.backup.generate_rclone_conf(destination_uuid, odest['url'], odest['provider'], odest)
            # Migrate parameters to private key space:
            mgx.hset('private/nodes/backup_destination/rclone_conf', destination_uuid, rclone_conf)
            mgx.delete('private/nodes/backup_destination/parameters/' + destination_uuid)
            mgx.hset('private/nodes/backup_destination/parameters/' + destination_uuid, mapping={
                'restic_password': odest['password'],
                'basepath': destination_basepath,
            })
            # Rebuild the public Redis key to clear its private
            # parameters:
            mgx.delete(krepo)
            mgx.hset(krepo, mapping={
                "name": odest.get('name', destination_uuid),
                "url": odest['url'],
                "provider": odest['provider'],
            })
            mgx.execute()
        except Exception as ex:
            print(agent.SD_WARNING + f"Failed migration of {krepo}", ex, file=sys.stderr)
    else:
        destination_uuid = None # No destination was migrated
    if destination_uuid:
        # At least one destination was migrated: trigger rclone-webdav
        # restart on all nodes:
        trx.publish(f"cluster/event/backup-destination-changed", json.dumps({
            "destination_id": destination_uuid,
        }))
    # The acl-changed event handler of each node will trigger backup
    # credentials generation and rclone-webdav reload:
    cluster.grants.save_acls(rdb)
